#!/usr/bin/env python3
import argparse
import logging
import pysam
import sys
import time
from case_control_filter.bit_utils import set_first_bits
from case_control_filter.vaf import get_vaf_method
from case_control_filter.genotype_filter import FormatFilter

PROG_NAME = "case_control_filter"
logger = logging.getLogger(PROG_NAME)
logger.setLevel(logging.INFO)
formatter = logging.Formatter(
    '[%(asctime)s] %(name)s - %(levelname)s - %(message)s')
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
ch.setFormatter(formatter)
logger.addHandler(ch)


def check_samples(vcf, samples):
    missing = [x for x in samples if x not in vcf.header.samples]
    if missing:
        raise ValueError("The following specified samples were not found in " +
                         "the VCF: " + ",".join(missing))


def get_format_filter(vcf, expressions):
    if not expressions:
        return None
    return FormatFilter(vcf=vcf, expressions=expressions)


def get_max_vafs(record, samples, vaf_func):
    vafs = []
    for i in range(1, len(record.alleles)):
        vafs.append(max(vaf_func(record, x, i) for x in samples))
    return vafs


def add_info_tag(vcf, tag):
    if tag in vcf.header.info:
        if vcf.header.info[tag].number != 1:
            raise ValueError("INFO tag '{}' already exists ".format(tag) +
                             "but has Number '{}' - will not overwite."
                             .format(vcf.header.info[tag].number))
        logger.warn("Overwriting pre-existing '{}' INFO field".format(tag))
    vcf.header.info.add(tag, '1', 'Integer',
                        'Bitwise flag indicating which values passed filter ' +
                        'expressions from ' + PROG_NAME)


def main(vcf, case=[], control=[], output=None, ignore_genotypes=False,
         case_expressions=[], control_expressions=[], min_case_vaf=None,
         max_control_vaf=None, vaf_ratio=None, info_tag=None,
         progress_interval=100_000, quiet=False, debug=False):
    if quiet:
        logger.setLevel(logging.WARN)
    elif debug:
        logger.setLevel(logging.DEBUG)
    output = '-' if output is None else output
    with pysam.VariantFile(vcf) as variants:
        check_samples(variants, case + control)
        vaf_calculation = None
        if min_case_vaf or max_control_vaf or vaf_ratio:
            vaf_calculation = get_vaf_method(variants)
        case_filter = get_format_filter(variants, case_expressions)
        control_filter = get_format_filter(variants, control_expressions)
        if info_tag:
            add_info_tag(variants, info_tag)
        out = pysam.VariantFile(output, 'w', header=variants.header)
        out.header.add_meta(key=PROG_NAME,
                            value=str.join(" ", sys.argv) + "; Date=" +
                            time.strftime("%Y-%m-%d %H:%M"))
        read, written = 0, 0
        for record in variants:
            if progress_interval and read:
                if read % progress_interval == 0:
                    logger.info(
                        "{:,} variants processed, {:,} written. At {}:{}"
                        .format(read, written, record.chrom, record.pos))
            read += 1
            n_alts = len(record.alts)
            filter_flag = set_first_bits(n_alts)  # bitwise flag per ALT
            for alt in range(n_alts):
                allele = alt + 1
                if not ignore_genotypes:
                    if all(allele not in record.samples[x]['GT'] for x in
                           case):
                        filter_flag &= ~(1 << alt)  # unset bit for ALT allele
                    if any(allele in record.samples[x]['GT'] for x in control):
                        filter_flag &= ~(1 << alt)
            # are we done already?
            if not filter_flag:
                continue
            if control_filter is not None:
                filter_flag &= control_filter.filter(record, control)
            if not filter_flag:
                continue
            if case_filter is not None:
                filter_flag &= case_filter.filter(record, case)
            if not filter_flag:
                continue
            ca_vafs = None
            co_vafs = None
            if max_control_vaf or vaf_ratio:
                co_vafs = get_max_vafs(record, control, vaf_calculation)
                if max_control_vaf:
                    for i in range(n_alts):
                        filter_flag &= ~((co_vafs[i] > max_control_vaf) << i)
                    if not filter_flag:
                        continue
            if min_case_vaf or vaf_ratio:
                ca_vafs = get_max_vafs(record, case, vaf_calculation)
                if min_case_vaf:
                    for i in range(n_alts):
                        filter_flag &= ~((ca_vafs[i] < min_case_vaf) << i)
                    if not filter_flag:
                        continue
            if vaf_ratio:
                for i in range(n_alts):
                    if co_vafs[i] > 0.0:
                        filter_flag &= ~((ca_vafs[i]/co_vafs[i] < vaf_ratio)
                                         << i)
                    elif ca_vafs[i] == 0.0:
                        filter_flag &= ~(1 << i)  # unset if case VAF is zero
            if filter_flag:
                if info_tag:
                    record.info[info_tag] = filter_flag
                out.write(record)
                written += 1
    logger.info("Finished processing {:,} variants. ".format(read) +
                "{:,} written, {:,} filtered.".format(written, read - written))
    out.close()


def get_options():
    parser = argparse.ArgumentParser(
        description='''Filter case/control pair VCF based on genotype and
        other format fields.''')
    parser.add_argument('vcf', help='Input VCF file')
    parser.add_argument('-o', '--output', help='Output VCF/BCF file')
    parser.add_argument('-t', '--case', '--tumor', nargs='+', required=True,
                        help='ID of case sample(s)')
    parser.add_argument('-n', '--control', nargs='+', required=True,
                        help='ID of control sample(s)')
    parser.add_argument('--ignore_genotypes', action='store_true',
                        help='''Do not use GT calls for filtering. Use this
                        option to ignore genotype calls and only filter using
                        other options (below).''')
    parser.add_argument('--case_expressions', nargs='+',
                        help='''Require case sample genotypes to match these
                        expressions. If more than one case sample is provided,
                        default behaviour is to require only one of these
                        samples to match given expressions. For example, to
                        only retain variants with a minimum GQ of 20 in at
                        least one case sample use "GQ > 20". If you require 2
                        or more samples to match an expression add the minimum
                        number as the fourth part of your expression (e.g. "GQ
                        > 20 2"). If you require ALL cases to match an
                        expression you can use "GQ > 20 all". You may also
                        combine expressions with logical (and/or) operators.
                        Parentheses are not supported. See the README for more
                        details.''')
    parser.add_argument('--control_expressions', nargs='+',
                        help='''Require control sample genotypes to match
                        these expressions. The same rules apply as for
                        --case_expressions. For example, to only retain
                        variants with an ALT AD less than 2 in all control
                        samples use "AD < 2 all".''')
    parser.add_argument('--min_case_vaf', type=float, help='''Minimum VAF for
                        case genotypes. Filter variants unless at least one
                        case sample has a VAF >= this value. VAF is
                        calculated using standard AD FORMAT fields if present.
                        Non-standard fields are supported for Platypus, Strelka
                        and SvABA.''')
    parser.add_argument('--max_control_vaf', type=float, help='''Maximum VAF
                        for control genotypes. Filter variants if any control
                        sample has a VAF >= this value. VAF is calculated using
                        standard AD FORMAT fields if present. Non-standard
                        fields are supported for Platypus, Strelka and
                        SvABA''')
    parser.add_argument('--vaf_ratio', type=float, help='''Filter variants if
                        (case VAF) / (control VAF) is less than this value. If
                        more than one sample is provided for case and/or
                        control samples the VAF ration will be calculated from
                        the samples with the maximum VAF. VAF is calcaulted as
                        for --min_case_vaf/--max_control_vaf options.''')
    parser.add_argument('--info_tag', metavar='TAGNAME', help='''Add bitwise
                        flag with this tag to the INFO field of your output.
                        Bits are set in the flag indicating which ALT alleles
                        match all parameters provided by the user.''')
    parser.add_argument('--progress_interval', type=int, metavar='N',
                        default=100_000, help='''Report progress every N
                        variants. Default=100_000.''')
    parser.add_argument('--quiet', action='store_true', help='''Suppress
                        progress messages and only show warnings.''')
    return parser.parse_args()


if __name__ == '__main__':
    args = get_options()
    main(**vars(args))
